class Solution {
    public void nextPermutation(int[] nums) {
        // Edge Cases
        // 1. Descending Order: If the digits of n are in descending order (e.g., 21), no greater permutation exists. Return -1.
        // 2. Single Digit: A single-digit number has no greater permutation. Return -1.
        // 3. 32-bit Overflow:

        int n = nums.length;
        int i= n-2;

        // 1. find first decreasing element
        while(i >= 0 && nums[i] >= nums[i+1]){
            i--;
        }

        // 2. find next larger element than i.. i.e smallest element larger than nums[i] (moving from right to left).
        if(i >= 0){
            int j = n-1;
            while(nums[j] <= nums[i]){
                j--;
            }

            // 3. swap i and j
            swap(nums, i, j);
        }

        // 4. reverse (i+1 to n-1)
        reverse(nums, i+1, n-1);
    }

    private void swap(int[] nums, int s, int e){
        int temp = nums[s];
        nums[s] = nums[e];
        nums[e] = temp;
    }

    private void reverse(int[] nums, int s, int e){
        while(s < e){
            int temp = nums[s];
            nums[s] = nums[e];
            nums[e] = temp;
            s++;
            e--;
        }
    }
}
