/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */


In the post order traversal, we need to account for two things:

Global Maximum Path Sum: This considers the current node as the root of the path and includes contributions from both its left and right subtrees. This value gives the highest path sum if the path is allowed to "turn" at the current node.
Current Path Sum: This is the maximum path sum at the current node that can continue upwards to its parent. A parent node can only use one of its child's paths in its calculation.
For clarity:

If a subtree's contribution is negative, it's better to ignore it entirely, as adding it would reduce the overall sum.
At each node, we calculate two values:
Maximum path sum considering the node as the root: node.val + leftMaxPath + rightMaxPath.
Path sum for continuation: node.val + max(leftMaxPath, rightMaxPath).



    class Solution {
    int res = Integer.MIN_VALUE; 
    //this variable will be used to store the result after each possible path and hence will finally store the max  path sum
    public int maxPathSum(TreeNode root) {
        if(root == null)return res;
        dfs(root);      //this will update the value or res as required
        return res;
    }
    public int dfs(TreeNode root){
        if(root == null)return 0;   //base case and very imp
        
        //at any node we want to find the left and right side max Sum
        int left = Math.max(dfs(root.left), 0);
        int right = Math.max(dfs(root.right), 0);
        // we are finding the max with 0 as we do not want to include any subtree with negative contributiuon. See explaination above
        
		
		//left here is storing the max possible contribution of the left subtree 
		//right here is storing the max possible contribution of right subtree
		//if either of left and rigth have a possitive contribution(value), the larger will finally be taken 
		
		//but first we will have to assume that the subtree with root node as root(the variable in this function) will have the largest sum path, so we will inlude this in our res if it has a value larger than previous res
        res = Math.max(res, root.val+left + right);
		
		
		//the function however is expected to return the contribution of the current subtree if the subtree was include as in case 1 explained above. It it was terminating here, left and right would have value 0
		//so we simply return the sum of the root val and the larger between left and rigth subtree sum
        return root.val + Math.max(left, right);
    
    }
} //do upvote if this helps
